\RequirePackage[l2tabu, orthodox]{nag}
%\documentclass[onecolumn,draft]{svjour3}
%\documentclass[onecolumn,final]{svjour3}
\documentclass[smallextended,final]{svjour3}
\usepackage{amsmath}
\usepackage[round]{natbib}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{microtype} % Finetunes spacing, load after fonts
\usepackage{siunitx}
\usepackage{alltt}
\usepackage{fancyvrb}
\usepackage{wrapfig}
\usepackage[colorlinks=false, pdfborder={0 0 0}]{hyperref} % Should be loaded last
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{subfigure}
\usepackage{cite}
\usepackage{verbatim}
\usepackage{tabulary}
\usepackage{amsmath}
\usepackage{mdwlist}

\newcommand{\nd}[2]{\frac{\mathrm{d} #1}{\mathrm{d} #2}}
\newcommand{\e}{\mathrm{e}}
\newcommand{\tn}{\newline}

\smartqed
\newbox\sfloat

\begin{document}


\title{Diffusion of Innovation in the Open Source Software Ecosystem}
\subtitle{An Empirical Study of the Gentoo Package Database} 
\dedication{}
\author{Remco Bloemen \and Chintan Amrit}
\institute{University of Twente}

\maketitle

%\tableofcontents

\begin{abstract}
Open source software projects have been at the centre of innovation in the software industry. However, the dynamics of open source project innovation and adoption remain under-researched. This is especially the case in large open source software ecosystems, where projects can depend on many projects as well as have many dependers. 

In this paper we make the case that software package dependencies are a form of  adoption of innovation. We then test this on the time-evolution of the Gentoo package dependency graph. We find that the Bass model of innovation diffusion fits the growth of the number of packages depending on a given library with an $\overline{R}^2 > 98\%$.
\end{abstract}


\section{Introduction}

Open source software has had a large impact on various aspects of software development and has been the source of  innovations in software technology, development process and even in software development business models \citep{ebert07}. Identifying innovative software projects as well as analysing their adoption is essential to arrive at an understanding of the diffusion of innovation of open source projects. However, literature on adoption of open source projects is at a preliminary stage, largely focussed on adoption of popular open source projects by organisations and end users \citep{aksulu10}.There is especially a dearth of research regarding the adoption of open source libraries (or even subsystems \citep{maccormack06}) that are the building blocks of large software projects \citep{szyperski04}. There is also a corresponding dearth of knowledge on the methods one can use to test the extent of adoption of software libraries over a period of time. In particular, there is a lack of understanding of how \emph{diffusion of innovation} occurs through the adoption of libraries in a open source ecosystem.

In this paper we not only analyse the adoption of open source libraries by other projects, but also use a method to test the diffusion of innovation of a software project - or the lifecycle of a project's adoption. We analyse the adoption of the open source libraries using the theoretical lens of \emph{diffusion of innovation} \citep{rogers03} and test it with a particular formalisation borrowed from the field of marketing research namely the \emph{Bass diffusion model} \citep{bass69}. Our central hypothesis is that  \emph{the growth in the number of open source software dependees of a project (its adoption) is a Bass innovation diffusion process.} In particular, we study  software innovation of the libraries in the Gentoo Portage  database from an adoption perspective. We first download the Gentoo Portage database for a time line of one month over a period of around 13 years (from 1 January to around mid 2012). We then calculate the dependencies among the libraries in each version of the database. Then, we calculate the change in the dependency graph of some well known libraries and check if this adoption of the library fits the Bass diffusion model \citep{bass69}.  We then analyse the adoption of 10 randomly selected libraries (we discard and replace those libraries whose adoption trends contain a lot of noise due to various reasons) compared to the Bass diffusion model. In all cases we find that the Bass diffusion model explains the adoption of the libraries (with an $\overline{R}^2 > 98\%$). This finding shows that the adoption of open source software libraries (in the Gentoo Portage database) does not differ from the adoption of other kinds of innovations as predicted by the theory of adoption of innovation, and in particular the Bass diffusion model. This finding, if found generalisable to most large open source libraries, can help in predicting their adoption over their lifetime. This can hence provide guidance to package managers and users of open source libraries.

% (Adoption reflects innovation 'better' than changes within packages. - Still cannot find a relevant reference!)


In the next section (section 2)  we describe the background literature of the paper, this is followed by the details of our method of extracting the dependencies of libraries in section 3. In section 4 we analyse the dataset and test the fit of the trends of library adoption with the Bass diffusion model. Section 5 discusses the results and in section 6 we conclude the paper by discussing the limitations of this study and provide some guidance for future work.
 


\section{Literature Background}


\subsection{ Open Source Software Ecosystems}
No software project stands entirely on its own. Software is usually developed by taking one or more existing libraries of components and combining those components in ways to create new products. Take for example a simple chat application. The chat application uses a different library for user interface development that provides components such as a window a text entry field and a button (that is labeled "send message" by the chat application). This user interface library in turn uses a graphics library to draw the lines, rectangles and text necessary for the fields and buttons. The graphics library uses a library to read font files and uses the fonts to turn text into pictures that can be displayed on the screen. The graphics library then sends the contents of the window to the window manager, which in turn uses a graphics card driver to instruct the hardware, and so on.  Such a collection of software projects that interact under the umbrella of a common software platform has been variously known as a software "ecosystem" \citep{manikas13}. 

The research on software ecosystems has primarily focussed on their business within a shared market or the relationships among the different businesses and hence deals with web and mobile platforms \citep{german13}.  Research on open source software ecosystems has focussed on the Debian Linux distribution \citep{gonzalez09, german07}, the Linux kernel \citep{godfrey00}, the eclipse platform \citep{wermelinger08} and recently GNU R \citep{german13}. These articles analyse the evolution of the ecosystems as growth in terms of number of packages and the dependencies among the packages and not in terms of adoption of innovation as we do in this paper.

In \citet{crowston08} published a comprehensive overview of academical research on open source software development. Of the 184 articles they cite, the vast majority of articles are case studies or surveys, with 4\% of the articles describing the development of empirical instruments and/or measurements. Also, most articles look at the level of a particular group or project, with 4\% looking at the societal level of interacting projects. Crowston et al. (2008) find no articles that develop instruments or measurements on the level of OSS packages \citep{crowston08}, which we aim to do in this paper.


\citet{haefliger08} study code re-use on six open source projects, they conclude that there is extensive code re-use in open source software. The article proceeds by identifying the process of code re-use, such as the drivers for re-using and the tools used to find relevant code. The study by Haefliger et al. (2008) looks at a given project and how it  re-uses existing components \citep{haefliger08}, whereas in this paper we analyse a given project and how it is being re-used by other projects. Additionally, we perform our analysis using a large set of automatically collected and processed empirical data.

\subsection{Software package dependencies}

\citet{lungu10} present multiple methods to automatically recover dependencies between software projects in an ecosystem. They arrive at a representation of the ecosystem that they call \textit{Ecco} that contains sufficient data to extract the dependencies of the ecosystem \citep{lungu10}.

\citet{german13} study the ecosystem of the GNU R project and determine the differences between the user-contributed packages and the core packages. They study the code characteristics, code evolution, dependency structures and the community surrounding the core and user-contributed packages. They find some significant significant differences in many of these aspects, and in particular they find that though user-contributed packages have been growing at a fast rate than the core packages, they remain stable in size over time \citep{german13}. Of particular interest to this paper, they examine the dependency structure of the R packages by analysing the \texttt{DESCRIPTION} file of each packages that describes the list of packages required by the particular package for proper installation. They then build an inter-dependency graph based on these package installation dependencies \citep{german13}. Their main findings related to this aspect is that there are consistently small number of dependencies for each package and that the peripheral packages have fewer dependencies \citep{german13}.

In their 2008 article, \citet{zheng08} analyse the dependency graph of the Gentoo Portage package database as it was in February 2007. The global structure of the graph is analysed in graph theoretic terms of sparsity, clustering coefficient, degree distribution and degree growth rate. The authors conclude that the graph can not be explained well by existing models of network growth and they propose two new models instead. Our study differs in two ways: First, we analyse the changes to the dependency graph over time, whereas Zheng et al. look at a particular instance in 2007 \citep{zheng08}. Second, we analyse and model the development of a given software package in the dependency network, instead of the overall development of the network. It can be interesting to study how the Bass diffusion model \citep{bass69} (described in detail below) for the development of individual nodes corresponds to Zheng et al. model for the development of the whole graph.



\subsection{Diffusion of Innovation and Adoption in Information Systems}\label{sect:DiffInn}

Innovation and adoption of technology in general has been studied by various researchers using the theoretical lens provided by \citet{rogers03}, the first edition of whose book came out in 1962 \citep{rogers62}. This theory, called the \emph{Diffusion of Innovation}, includes factors such as the characteristics of the particular technology, characteristics of the adopters and the means by which the adopters learn about and are persuaded to adopt the technology \citet{rogers03}. Among other studies, it has been used to analyse the adoption of software process technology in commercial organisations and make predictions about the adoption of object oriented approaches to software development\citep{fichman93}, effect of the reuse of open source components on software development economics \citep{ajila07} and the effect of developer involvement. diffusion environment and the mediating influence of perceived developer control over IT diffusion success \citet{green00}.

\citet{bonaccorsi03} conduct a simulation to compare the relative end user adoption of open source versus proprietary software. They model the adoption decision of heterogeneous interacting agents based on four factors; the perceived intrinsic value of the open source software, the negative network effect arising from the dominating proprietary standard, the positive network externality effect arising from the community of open source developers and the competitive reaction of the dominating commercial software companies \citep{bonaccorsi03}. They find that the diffusion of open source software is difficult and takes a long time when a dominating proprietary standard exists, that the diffusion depends on the initial distribution of intrinsic value and that current dominant proprietary software companies can hinder or stop the diffusion of competing technology by investing heavily in research and development activities. However, they also note that under many conditions proprietary software and open source software can co-exist \citep{bonaccorsi03}.

\citet{dedrick04} and \citet{chen06} study the adoption process of open source software by (commercial) end users. Their focus is on the competitive economic strengths of open source software versus commercial software. The conclusion is that cost is the most important driver for open source adoption and freedom and extensibility play a lesser role. The articles do not provide empirical data on the adoption process itself, which makes it hard to compare it to our empirical results in this paper.

\emph{Diffusion} is the process of market uptake of an innovation, the users of a particular innovation are called \emph{adopters} \citep{narayanan01}. Taking the open source projects as a 'market', these concepts can be applied to libraries and dependencies. For example, consider the projects with a graphical user interface (GUI). These have a demand for a GUI toolkit, and there are several competing implementations available (\verb|Qt|, \verb|GTK|, \verb|Wx|, etc.). The introduction and uptake of a new GUI toolkit is a process of innovation diffusion and the projects that use a particular toolkit can be considered adopters of that toolkit. When talking about software projects such a relation is often called a \emph{dependency}.

In the next section we describe the Bass diffusion model \citep{bass69}, followed by the results of our analysis of fitting the Bass diffusion model onto the change in the adoption of the packages belonging to the Gentoo portage database. 


\subsection{The Bass diffusion model}\label{sect:Bass}

Once an innovation is released to the public a process starts where an increasing portion of the market decides to use the innovation. In the theory of innovation dynamics this process is called diffusion and the users are called adopters \citep[see][chapter 4]{narayanan01}.

To model the process of innovation diffusion \citet{bass69} introduced two processes that propagate an innovation. The first processes involves individuals that decide to use an innovation based on their perception of its merits, without looking at the experiences of others. The second process involves the word-of-mouth effect or the bandwagon effect, where individuals adopt the innovation solely because they hear of the experiences of previous adopters. Of course in reality everyone will be somewhere in between these two extreme types, but for the sake of modelling it suffices to consider the relative abundance of both types.

It should be noted that \citet{bass69} and many of the later authors, use confusing terms to describe the two types of adopters. The first type are called "innovators", not to be confused with those actually inventing the innovation and the second type are called "imitators", not to be confused with those developing imitating offerings. The terms seem more intuitive if one remembers that the model concerns the demand side of the market and not the supply side.

We now proceed to describe the mathematical model used by \citet{bass69}. To model the diffusion process, let $M$ be the total market size for the innovation and $A$ the current number of adopters, such that $0 \ge A \ge M$. The two adoption processes can then be described as follows: \citep[see also][]{bass10,mahajan90}

\emph{Innovators}: Some individuals in the market who do not yet use the innovation, might decide to adopt the innovation. The rate at which this happens is $p$, the coefficient of innovation. The number of users that do not use the innovation is $M-A$, so the inflow of adopters is $p(M-A)$.

\emph{Imitators}: The people who use the innovation can express their fondness to people who do not yet use the innovation, which can influence them to adopt the innovation. The rate at which this happens is $q$, the rate of imitation. The number of users that do not use the innovation is again $M-A$, the chance of meeting someone that does use the innovation is proportional to $\frac{A}{M}$ so the inflow of imitators can be modelled as $q\frac{A}{M}(M-A)$.

When these two effects are combined, the net inflow of users, represented by the time derivative of $A$, can be modelled as:
\begin{align*}
\nd{A}{t} &= p(M - A) + q\frac{A}{M}(M - A) \\
&= \left(p + q\frac{A}{M} \right)(M - A)
\end{align*}

Often one is not concerned with the market size $M$ and only interested in the fraction of the market---denoted with $F$---that uses the innovation. Of course, $F=\frac{A}{M}$. By dividing the above equation with $M$ one obtains the Bass model:

\begin{align}\label{eq:bass-ode}
\nd{F}{t} &= \left(p + q F\right)(1 - F)
\end{align}

\citet{bass69} solves this ordinary differential equation, and arrives at the following function for $F$:

\begin{align}\label{eq:bass-direct}
F(t) &= \frac{1 - \e^{-(p+q)t}}{1+\frac{q}{p}\e^{-(p+q)t}}
\end{align}

\begin{wrapfigure}{r}{0.5\linewidth}
\small\centering
\includegraphics[width=\linewidth]{Bass.pdf}
\caption[Bass model of innovation diffusion]{The Bass model of innovation diffusion. The blue trace represents a Bass diffusion with $p=0.01$ and $q=0.90$. The purple trace bass diffusion with $p=0.90$ and $q=0.01$.}
\label{fig:bass}
\end{wrapfigure}

In figure~\ref{fig:bass} two Bass diffusions are plotted using equation \eqref{eq:bass-direct}, one representing an innovation diffusion with many innovators and a few imitators and one representing a diffusion with many imitators and a few innovators. When there are more imitators it takes a while for the innovation to be adopted since the majority of the potential users are waiting for someone else to try it first.

To fit the model of equation~\eqref{eq:bass-direct} to empirical data two additions are necessary. First the market size has to be re-introduced, this is done by taking $A(t) = M F(t)$. The market size, $M$, in this equation represents the total number of potential adopters for this specific product, not the total number of adopters for a category of products. Since it is not possible to know in advance who will eventually be using an innovation, it is difficult to determine $M$ in advance. Furthermore, the Bass model assumes the market size to be constant and competition free, which is unlikely in practice. Therefore the quantity has to be fitted to the data. Statistical goodness-of-fit measures can then be used to determine the validity of the assumptions. The second addition to the basic model is the time at which the innovation is introduced. Until now the assumption was that the introduction was at $t=0$, in arbitrary units. For empirical data fitting it is necessary to be able to specify an arbitrary introduction time. This can be achieved by introducing the introduction time $t_0$ in the equation as $A(t) = M F(t - t_0)$. Again, this variable can be fitted if it can not be determined in advance.

\begin{align} \label{eq:bass-model}
	A(t) &= M \frac{1 - \e^{-(p+q)(t-t_0)}}{1 + \frac{q}{p}\e^{-(p+q)(t-t_0)}}
\end{align}

Equation~\eqref{eq:bass-model} incorporates the two additions and can be readily applied to empirical data. In \citep{mahajan95} and many other empirical studies this happens in the differential form, since generally only absolute sales data are available and not absolute user data. The dependency graph method presented later allows one to obtain absolute usage number, so the differential form is not further used. 

The interpretation of the variables and parameters and their dimensions is presented in table~\ref{tbl:bass-model}. When applying the formula, one should note that it is non-linear, so ordinary linear regression can not be used. Instead one can use non-linear least squares regression, while noting the correct number of the degrees of freedom. This can be done using existing mathematical/statistical packages. In this paper we used the \verb|NonlinearModelFit| procedure in Mathematica. 

\begin{table}
\centering\small
\caption[Bass model variables and parameters]{Overview of the variables and parameters of the Bass model as presented in equation~\eqref{eq:bass-model}.}
\label{tbl:bass-model}
\begin{tabular}{cll}
\toprule
& Dimension & description \\
\midrule
$A$   & adopters    & adopters at a the model time \\
$t$   & time        & model time \\
\midrule
$t_0$ & time        & time of innovation introduction \\
$M$   & adopters    & number of potential adopters \\
$p$   & time$^{-1}$ & rate of adopter innovation \\
$q$   & time$^{-1}$ & rate of adopter imitation \\
\bottomrule
\end{tabular}
\end{table}

%Repetition of the earlier text follows:
\begin{comment}

 To model the process of innovation diffusion, \citet{bass69} introduces two processes that propagate an innovation. The first processes involves individuals that decide to use an innovation based on their perception of its merits. The second process involves the word-of-mouth effect or the bandwagon effect - individuals adopt the innovation because they hear of the experiences of previous adopters. In reality however, people lie somewhere in between these two extreme types. For the sake of modelling, it suffices to consider the relative contribution of both types. It should be noted that for historical reasons \citet{bass69} and all later authors use the following terms; the first type are called "innovators", not to be confused with those actually inventing the innovation and the second type are called "imitators", not to be confused with those developing imitating offerings. Taking $M$ to stand for the total market size and $A$ to stand for the total number of adopters the Bass diffusion can be modelled with two simultaneous processes:

\emph{Innovators}: Market participants not using use the innovation yet might decide to adopt the innovation. The rate at which this happens is $p$, the coefficient of innovation. The number of user that do not use the innovation is $M-A$, so the inflow of adopters is $p(M-A)$.

\emph{Imitators}: Users of the innovation can express their fondness to market participants who do not yet use the innovation. This can influence them to adopt the innovation at a rate $q$, the rate of imitation. The number of user that do not use the innovation is again $M-A$, the chance of meeting someone that does use the innovation is proportional to $\frac{A}{M}$ so the inflow of imitators can be modelled as $q\frac{A}{M}(M-A)$.

When these two effects are combined the net inflow of adopters represented by the time derivative of $A$ can be modelled as

\begin{align}
	\nd{A}{t} &= p (M-A) + q\frac{A}{M}(M-A) \text{.}
\end{align}

This first order homogeneous ordinary differential equation can be solved for $A(t)$ to give

\begin{align} \label{eq:bass}
	A(t) &= M \frac{1 - \e^{-(p+q)t}}{1 + \frac{q}{p} \e^{-(p+q)t}} \text{.}
\end{align}

The solution assumes the innovation is introduced at time zero, to account for this the substitution $t \rightarrow t - t_0$ is made. This results in four parameters, $t_0$, $M$, $p$ and $q$ that can be fit to the empirical data.

\end{comment}
%End repetition

\section{The Gentoo Portage Dataset}
%Why Gentoo?
To apply the techniques described above, we need accurate project dependency information over time. There are four qualities a dataset should have to produce good and relevant innovation information that can arguably be generalised to the open source community as a whole, these are:

\begin{itemize}

\item Reliable list of projects - A good dataset should contain as many projects as it can (completeness) with as much heterogeneity as it can. Or, put differently, with as little bias as it can (neutrality).

\item Presence of correct inter project dependencies - A good dataset needs to be monitored to make sure there are no important project dependencies that are missing as well as no extraneous dependencies present.

\item Chronology of the data - The dataset should not only contain a list of projects and dependencies, but also track how this changes over time. Here we are interested in the resolution and timeliness of the dataset. Resolution refers to the minimal discernible unit of time in the dataset. If the dataset is produced by taking monthly snapshots of the projects and their relations, then the resolution would be one month. Timeliness refers to the responsiveness of the data gathering method to changes. When a project or dependency gets added or removed, will this be apparent in the next snapshot? Or will it take a while for the information to trickle through.

\item Availability - From a practical point of view it is advantageous if the dataset is easily available and codified.  By easily available, we mean that the dataset can be obtain by reasonable means, for example by downloading from one location. By codified, we mean that the data is written in a manner that allows automated processing

\end{itemize}

We found the Gentoo Portage data source to satisfy all these conditions, especially with regard to having more complete project dependencies and frequent release cycles (also see Appendix B).
Now that a data source is selected, we extract the required information and process the data into a form that allows easy calculations. The major steps are collecting the raw data, parsing this into a simpler format and producing the final dependency graph from this simpler form. Some post-processing can then be done on the dependency graph. In the process, the dataset we find that the dataset shrunk from thirteen gigabytes (taking more than a week to collect), to thirty megabytes that could be processed in four seconds.

In the remainder of this article, the terms `project', `package' and `library' will be used as synonyms for a node in the dependency graph.

The empirical data used is the time evolution of the Gentoo Portage package dependency graph \citep{bloemen14b}. This dataset contains the full dependency graph for every month since the project was initiated in $2000$, the resulting graphs have a combined total of 1.3 million packages and 6.9 million dependency relations, with the largest graph having 15 thousand packages and 80 thousand dependency relations.

More information about a packages can be found at
\begin{align}
\mbox{
\href{https://packages.gentoo.org/package/dev-vcs/git}{\texttt{https://packages.gentoo.org/package/\textcolor{MidnightBlue}{dev-vcs/git}}}
}\label{url:pkg}
\end{align}
where \texttt{\textcolor{MidnightBlue}{dev-vcs/git}} is replaced with the name of the package.

\subsection{Collecting}

The Gentoo portage database consists of a large number of text files, at least one for every version of every package, contained in a large directory structure. This entire structure is kept in a CVS revision control system that has tracked all changes to the database since the start of the project around 2000.

Using the \verb|cvs| command one can download the entire database as it was at a certain point in history. For example the following command would download the database, as it was on 1 December 2003:

\begin{align}
\mbox{\texttt{cvs -d :pserver:anonymous@anoncvs.gentoo.org}}&\;\backslash \notag\\
\mbox{\texttt{  /var/cvsroot co -D 12/01/2003 gentoo-x86}}
\label{cmd:cvs}
\end{align}

Using a small utility written for the task, this command was repeatedly invoked to download all the databases from 1 January 2000 until mid 2012, with increments of one month. The \verb|.ebuild|, \verb|.eclass| and \verb|.eblit| files are stored. Other files were ignored, to save space since they contain no relevant information. This whole downloading processes took about a week and a half and the resulting database consisted of three million files occupying thirteen gigabytes of space. There were also files specifying packages renames, but since these only get appended to and never deleted, they were taken from the latest version of the database.

\subsection{Parsing}

The files are written in a text based computer language called `ebuild' which is based on the Bash shell script language. Being a scripting language, the files can refer to other files and include complicated code to calculate dependencies on demand. This eases the task of the script developer, since he can automate many processes, but it complicates the task of extracting data. We tried several approaches to extract the data in the industrial quantities the analysis requires.

The first approach was to use Paludis and its C++ bindings to load a repository and extract metadata. Paludis is a tool designed to process ebuild files, we then query its database interface to gather all the dependency information from all the packages. This approach takes a lot of time, it requires around a half an hour per database version, but it failed on some of the older databases because the format of the database changed over time.

% Eclasses
The second attempt was to use a custom build metadata extraction program that also supports an older version of the database. This parser looks for text patterns resembling dependency specifications and implements only a minimal amount of the ebuild file format (basically only dependencies and the \verb|inherit| inclusion statement). This technique is very fast, processing the entire set in 70 minutes, but fails on the newer databases that use complex techniques such as macros in the dependency specifications.

The final method is a hybrid of the first two, using the Paludis' \verb|instruo| command to pre-process and expand all the macros to create simplified versions that can be parsed using the custom parser. The \verb|instruo| command was run on every version of the downloaded database. When the command failed on a package (the older format ones), the original was kept. The total running time of this operation was around four days.

\subsection{Producing the Dependency Graphs}

\begin{wrapfigure}{r}{0.5\textwidth}
\small\centering
\begin{BVerbatim}
>=media-libs/taglib-1.6.1[asf,mp4]
>=media-libs/taglib-extras-1.0.1
player? (
    app-crypt/qca:2
    >=app-misc/strigi-0.5.7[dbus,qt4]
    || ( >=dev-db/mysql-5.0.76
         =virtual/mysql-5.1 )
    >=kde-base/kdelibs-4.3[opengl?,
                   semantic-desktop?]
    sys-libs/zlib
    x11-libs/qt-script
    >=x11-libs/qtscriptgenerator-0.1.0
\end{BVerbatim}
\caption{Fragment of the runtime dependencies of the Amarok music player.}\label{fig:amarokruntime}
\end{wrapfigure}

Now the data was in 154 snapshots of the package database in a simplified text based format. This is several gigabytes and several millions of files large and needs to be processed into dependency graphs. This is naturally very difficult to do manually, therefore more specialised tools were developed.

By design the database can work with complicated dependency relations, such as ``package \verb|amarok| requires package \verb|phonon-kde|, minimum version \verb|4.3|, but only when feature \verb|player| is required''. This would be coded as \verb|player?| \verb|(| \verb|>=kde-base/phonon-kde-4.3| \verb|)|. An example of the run time dependencies for the Amarok music player is given in figure~\ref{fig:amarokruntime}. The figure includes more complex rules such as ``either package X or package Y is required'', `` package X is required to contain feature Y'', etcetera.

% Ignoring version specifiers, conditionals, blocks, use flags
These conditional rules are relevant when compiling and running software, but the conditions are not necessary when analysing component use from an innovation perspective. If Amarok has an optional dependency on a package, the developers of Amarok are actively using the innovation provided by that package even though it may not be enabled by the end user in the final product. For this reason, and for the sake of simplicity, all the conditionals are ignored when parsing the ebuilds.

% Only process latest version at the time of the snapshot
When a database snapshot contains several versions of the same package, only the latest is used. For some of the analysis techniques presented in the version information might be relevant, but at this point it was decided not to include different versions to simplify processing analysis. When several versions where available in the database at a certain point in time, only the highest version was included. This ensures that each snapshot represents the state of art at that point of time.

% Parsing DEPENDS, RDEPENDS and PDEPENDS
In the Gentoo Portage database, the dependencies are sorted in two kinds, compile time dependencies and runtime dependencies. The first kind is required to build and install the package. The second kind is only required when actually using the package. The reason for this distinction is a technical one: it solves installation issues with cyclical dependencies. For our research purpose, both kinds of dependencies are considered equal.

\begin{wraptable}{r}{0.5\textwidth}
\vspace{-1em}
\small\centering
\caption{Key figures of the dataset}\label{tbl:dataset}
\begin{tabular}{ll}
\toprule
\multicolumn{2}{c}{\emph{Time}} \\[0.5mm]
Period & 2000 to Q1 2012 \\
Resolution & Monthly \\
Snapshots & 154 Graphs \\
\midrule
\multicolumn{2}{c}{\emph{All graphs}} \\[0.5mm]
Nodes & 1.3 Million \\
Vertices & 6.9 Million \\
\midrule
\multicolumn{2}{c}{\emph{Final graph}} \\[0.5mm]
Nodes & 15 Thousand \\
Vertices & 80 Thousand \\
\midrule
\multicolumn{2}{c}{\emph{Raw ebuilds}} \\[0.5mm]
Format & SquashFS \\
Size & 239 MB (compressed) \\
 & 4.4 GB (uncompressed) \\
Files & 2,990,722 \\
\midrule
\multicolumn{2}{c}{\emph{Compressed graphs}} \\[0.5mm]
Format & Tar+XZ compressed GML \\
Size & 2 MB \\
\bottomrule
\end{tabular}
\vspace{-1em}
\end{wraptable}

% Package moves
Sometimes, packages get renamed or moved around in the database and this needs to be accounted for. Luckily, to allow users to upgrade from an older version to a newer version the processing of moves and renames has been automated in the Gentoo Portage database. The developers maintain a list of all the moves and renames that have occurred in a structured format (in the database). The latest version of this list is used to retroactively change all the package names (in the historical snapshots) to their modern name. This ensures that moves and renames do not harm the historical continuity in the dataset.

% Package provides
Using all the observations and choices made above, a tool was developed to extract dependency graphs from all the simplified database snapshots. The shear scale of the resulting dataset, $1.3$ million packages and $6.9$ million dependency relations, required a solution to store efficiently. Therefore, a compressed format was developed that only stores the changes between the historical snapshots instead of storing whole snapshots. The extraction process took three hours and resulted in a $29$ megabyte file. Reading this file into memory resident data structures and performing simple queries took about $4$ seconds. The dataset is now in a usable form. Table \ref{tbl:dataset} provides the key figures of the dataset, while the details of the data structure can be seen in Appendix 1.

\section{Exploration of the Dataset}

\begin{figure}
\small\centering
\subfigure[Total number of packages]{\includegraphics[width=0.45\textwidth]{packageCountUnfiltered2.pdf}\label{fig:pkgsgrowth}}
\subfigure[Additions and removals]{\includegraphics[width=0.45\textwidth]{packageCountDeltaUnfiltered2.pdf}\label{fig:pkgsgrowthdelta}}
\caption{Growth of the Gentoo package database over time.}\label{fig:pkgsgrowth}
\end{figure}

In figure~\ref{fig:pkgsgrowth} the number of packages in the database is plotted over time. One can see how the database started in 2001, underwent a period of rapid growth between 2002---2006 and settled into calm a linear growth from 2006 onwards. In figure~\ref{fig:pkgsgrowthdelta} the rate of introducing and removing packages is plotted over time. This shows two spikes, one at the start of 2002 and one in 2005. The cause of these spikes was not thoroughly investigated, but a likely cause is a massive cleanup and refactoring of the database. This is a warning sign that the data, exactly at these points, might contain a lot of noise. In general, the data before 2006 should be considered with more caution than the data afterwards.

The effect of the growth of the entire dataset on the number of dependencies for individual packages was investigated, but no influence was found. Since the total number of packages grows one would expect the `market' for a certain package to grow and thus the number of dependency relations to that package to grow. To compensate for this one could divide the number of dependers by the total number of packages, compare this with using a market-share instead of an absolute number of users. In practice, this only made a significant difference for early data, but that was determined to be unreliable. In the interest of keeping the analysis simple, no compensation was made for the growth of the number of packages.

One of the first things attempted after generating the dataset was to visualise the entire graph of the latest snapshot. The problem is, to make any sense of a graph it has to be laid out visually on a plane, nodes that are connected should be placed close to each other so that connecting lines are short and have little overlap. We tried software packages such as Graphviz, Tulip, Gephi, Jetty and Cytoscope, but after days of trying and many hours of calculation, none were able to produce any insightful visualisations for the sixteen thousand nodes and hundred thousand relations.

\begin{figure}
\small\centering
\subfigure[Dependencies per package]{\includegraphics[width=0.45\textwidth]{histo-out.pdf}\label{fig:dephisto-out}}
\subfigure[Dependers per package]{\includegraphics[width=0.45\textwidth]{histo-in.pdf}\label{fig:dephisto-in}}
\caption{Double logarithmic histograms of the number of incoming and outgoing dependencies per package.}
\end{figure}

Since it was impossible to get a visual overview of the entire dependency graph, its structure was plotted using histograms. Figure~\ref{fig:dephisto-out} is a histogram of the number of dependencies per package. A log-log scale was required to make the plot insightful reflecting the fact that there are many packages with only zero, one or a few dependencies and a few packages with a lot of dependencies. Statistically this means the distribution of the number of dependencies has a fat tail. Likewise, the number of dependers for each package is plotted in figure~\ref{fig:dephisto-in}. This can be interpreted as the distribution of the number of adopters of a given technology. Again, there is a fat tail, even fatter than the one from the number of dependencies. The approximate linearity of the histogram suggests a power-law like distribution of the number of adopters for a given technology. \citet{zheng08} suggest that the structure of package dependency networks is not comparable to known models of social networks and have developed their own model to explain the graph structure.

\subsection{The KDE Subgraph}

The entire graph might be difficult to visualise, but a small part should be easier. The problem with choosing a small part is that the part must have a meaningful boundary, a random selection will likely have few relations and miss some key packages. It was therefore decided to only pick the packages that belong to the KDE desktop environment. The primary reason is that the first author was familiar with this set of packages and knew its structure in some detail. A secondary reason is that the packages were developed by a tightly connected community where component reuse among the projects was stimulated by creating libraries. The selection was implemented by considering only packages in the category \verb|kde-base| from the Gentoo Portage database.

The program Tulip was used to visualise the graph, the result can be seen in figure~\ref{fig:kde2}. First the graph was laid out using a force based method, this clusters packages that are strongly connected close to each other. Then the graphs where coloured according to their $k$-core measure, this is a measure for the `connectedness' of a package. At this point there was still an unclear mess of lines between the packages, which was resolved by bundling the edges. Edge bundling merges neighbouring lines to a single thicker line and this creates a vein-like structure. 

\begin{figure}
\small\centering
\includegraphics[clip,trim=0 0 1cm 10cm,width=\linewidth]{kde.pdf}
\caption{Internal dependencies of modules in the KDE project. Color represents the $k$-core measure. The graph edges have been bundled to improve readability.}\label{fig:kde2}
\end{figure}

In figure~\ref{fig:kde2} one can see that all the packages depend on \verb|kdelibs|, the large blue dot in the middle. The \verb|kdelibs| package provides a lot of basic functionality, such as a unified set of icons, file open/save dialogues and fewer visible standard components. Almost all the packages in the KDE set require one or more of these components. It should be stressed that there was no manual work involved in the layout of this graph, Tulip was able to determine using only objective, deterministic mathematical methods from graph theory that \verb|kdelibs| plays a central role in the KDE technology.

The second thing to notice are the clusters that form along the edge of the figure. All these clusters represent related areas of technology within KDE. The brownish-grey cluster immediately at the top contains mostly educational software and a few file utilities. Going clockwise, the little blue cluster next to it contains programs for compact discs. The large brownish-grey cluster on the right consists exclusively of games and supporting technologies. The complex mesh that starts around seven o'clock begins with technology used to allow users to log in. It then proceeds towards hardware related technology and desktop infrastructure. The big blue dot marked `solid' at eight o'clock is KDE's hardware abstraction layer. At nine o'clock the big blue dot represents the notification library, used to notify users of hardware events (``battery low'' and the likes), appointments or incoming emails. The mesh now shifts towards personal information management at ten o'clock. These contain utilities such as an email client, a note taking application, a chat client and a calendar application and related technologies. Lastly, the small brown-grey cluster at eleven o'clock contains technology to allow integration of scripting languages.

Scattered throughout the figure are yellow dots containing packages that are only connected to \verb|kdelibs|, without any apparent pattern in their location. This was expected since the packages only depend on \verb|kdelibs| and are not depended upon by other packages. This means there is no information that brings any insight into their nature and where to cluster them. Perhaps if dependencies from outside the KDE subset where included, we would find that the packages would form more clusters.

It is remarkable how only a few dependency relations provide sufficient clues for the clustering algorithm to automatically find related areas of technology. Similar but faster clustering techniques where used on the whole snapshot with similar results. Related packages for certain programming languages (Perl, Php, Java, Python, Ruby) would cluster and packages related to either KDE or GNOME would cluster, among many more. Unfortunately the analysis software was struggling with the size of the dataset and the full set was not investigated further.

\section{Results and Discussion}

% \begin{wrapfigure}{r}{.5\linewidth}
% \small\centering
% \label{fig:BassFits}
% \subfigure[\texttt{libnotify}: $p=0.05$, $q=0.72$]{\includegraphics[width=0.45\textwidth]{BassFit-libnotify.pdf}}
% \subfigure[\texttt{libtheora}: $p=0.11$, $q=0.63$]{\includegraphics[width=0.45\textwidth]{BassFit-libtheora.pdf}}
% \subfigure[\texttt{taglib}: $p=0.22$, $q=0.04$]{\includegraphics[width=0.45\textwidth]{BassFit-taglib.pdf}}
% \subfigure[\texttt{udev}: $p=0.01$, $q=0.50$]{\includegraphics[width=0.45\textwidth]{BassFit-udev.pdf}}
% \subfigure[\texttt{cairo}: $p=0.005$, $q=0.35$]{\includegraphics[width=0.45\textwidth]{BassFit-cairo.pdf}}
% \caption{The Bass curve fitted on a number of packages}
% \end{wrapfigure}

From the entire list of packages, a few well-known (at least according to the authors) packages were selected. The selection criteria was that the package must not have existed before (around) 2004, because the Gentoo Portage database was still too immature then, and that the package must have gained a considerable number of dependers since its introduction. In table \ref{tbl:results}, we list some the packages along with their parameters. In these cases the adjusted coefficient of determination $\overline{R}^2$ was more than $99\%$.

Special tools where developed to extract the time series of the number of adopters $A_t$ for a given package. This time series was then fit to equation \eqref{eq:bass-model} using Mathematica's \texttt{NonLinearModelFit}. The goodness-of-fit was analysed using an ANOVA table and calculated using the adjusted coefficient of determination $\overline{R}^2$. The parameters were extracted from the fit, and confidence intervals were calculated under assumptions of normality. In table \ref{tbl:results} the relevant parameters are presented with their mean value and a $95\%$ confidence interval. Since normality was assumed, the confidence intervals ignore the $p \ge 0$ and $q \ge 0$ constraints. 

The plots were drawn using a red line for the model and shades of red for the confidence bands. The red line was drawn according to equation \eqref{eq:bass-model}, with the mean values used as parameters. Then single value predictions confidence bands were calculated for $90\%$, $95\%$, $99\%$ and $99.9\%$ confidence levels and these were drawn in progressively darker shades of pink. They represent a prediction for where a single additional value would likely fall. According to the model and the uncertainty introduced by the fit, there is a $90\%$ chance that it will fall in the innermost band, $95\%$ chance that it would fail in the second band, etc. If the data fits the model properly, one would expect to see $90\%$ of the points in the inner band. Finally, the empirical data points were plotted as black dots, connected with a thin vertical line - the residual error of the model.

It turns out that the packages can be classified as mostly imitator driven, mostly innovator driven and in a few exceptional cases of growth and demise.

\begin{table}
\small\centering
\caption{Results of fitting the Bass model.}\label{tbl:results}
\begin{tabular}{lr@{ $\pm$}rr@{ $\pm$}rr@{ $\pm$}rr}
\toprule
Package & \multicolumn{2}{c}{$p$} & \multicolumn{2}{c}{$q$} & \multicolumn{2}{c}{$M$} & $\overline{R}^2$\\
\midrule
\texttt{git}         & 0.00 & 0.01    & 0.73 & 0.13   & 746 & 394 & 99.27\%\\
\texttt{libnotify}   & 0.05 & 0.08    & 0.72 & 0.30   & 103 &   9 & 99.23\%\\
\texttt{udev}        & 0.01 & 0.01    & 0.50 & 0.12   & 200 &  65 & 99.05\%\\
\texttt{cairo}       & 0.01 & 0.01    & 0.43 & 0.09   & 249 &  44 & 99.73\%\\
\texttt{libmad}      & 0.18 & 0.14    & 1.13 & 0.3    &  55 &   1 & 99.68\%\\
\texttt{libtheora}   & 0.11 & 0.09    & 0.63 & 0.21   &  32 &   1 & 99.75\%\\
\texttt{taglib}      & 0.22 & 0.03    & 0.04 & 0.06   &  62 &  12 & 99.40\%\\
\bottomrule
\end{tabular}
\end{table}

\subsection{Imitator Driven Growth}

\begin{wrapfigure}{r}{0.5\textwidth}
\small\centering
\includegraphics[width=\linewidth]{BassFit-git2.pdf}
\caption{The imitation driven adoption of \texttt{git}.}\label{fig:git}
\vspace{-1em}
\end{wrapfigure}

The first package we consider is \verb|git|, a modern revision control system that shows an imitator driven adoption. It's growth can be seen in figure \ref{fig:git}, the corresponding statistics are in table \ref{tbl:results}. The package first appeared just before 2005, it had around ten packages depending on it in 2006, twenty in 2008 and is currently used by almost three hundred packages. According to the Bass model, it will continue to grow to approximately 750 users. The innovator inflow is only $0.2\%$ of the potential market per year, so one would expect $0.002\cdot (750 - 300) = 1$ users to adopt \verb|git| out of sheer innovation. Taking the analogy to people, if someone from the $450$ current non-users were to meet a random person from the entire $750$ market, there is a $\frac{300}{750}= 40\%$ chance of meeting a user which can convince him/her to start using \verb|git|. The chance of this happening is the imitator inflow $q = 0.73$. Therefore, the total number of users \verb|git| can expect to gain from imitation this year is $450\cdot 40\%\cdot 0.73 = 131$. Implying that the market is very much imitator driven.

The relative slowness of \verb|git|'s growth and its dependence on imitation can be explained. Open source projects, and software projects in general, consist of numerous large textual files containing source code. Changes made in one place can hugely and unpredictably affect other places. To complicate matters further, usually more than one developer works on the source code at the same time. There are competing systems such as \verb|cvs|, \verb|subversion|, \verb|mercurial|, etc., but the basic functionality of maintaining versions is provided by all of them. Thus two explanations can be derived for \verb|git|'s growth: first, the revision control system is not a part that affects the products delivered by the open source project and second, there is little incentive to switch unless the new revision control system proves to be superior.

\verb|libnotify| is a library for notifications. In modern desktop environments applications may want to notify the user of certain events, for example a battery that is about to go empty, a new email or an incoming phone call. The adoption is relatively slow, despite its usefulness. A possible explanation is that the target applications all have their own custom solutions, which the developers are keen to keep.

\verb|udev| is a device manager. Its task is to communicate closely with the hardware drivers in Linux kernel to monitor any changes in the hardware configuration. It represents an architectural change in a very low level component, this might explain its slow imitator driven growth.

\verb|cairo| is a graphics library. It provides facilities for drawing lines, circles, text and other graphics primitives and is used by user graphics-heavy projects such as user interface libraries. Much like \verb|udev| its adoption represents an architectural change at a low level, this might explain its similar growth pattern.


\subsection{Innovator Driven Growth}

\begin{wrapfigure}{r}{0.5\textwidth}
\vspace{-2em}
\small\centering
\includegraphics[width=\linewidth]{BassFit-libmad2.pdf}
\caption{The innovation driven adoption of \texttt{libmad}.}\label{fig:libmad}
\vspace{-1em}
\end{wrapfigure}

A typical example of innovator driven growth is given by \verb|libmad|. The model is fitted resulting in figure \ref{fig:libmad}. Again, the data is neatly explained by a Bass diffusion process and in particular, the rapid steep growth and the stable user base afterwards. The name of the project is an acronym for ``library for MPEG Audio Decoding'' and the package provides a high quality mp3 decoder for use in multimedia applications. This might also explain the rapid growth of its adoption: multimedia applications can benefit a lot from good quality mp3 support.

\verb|libtheora| is a library for the Schroedinger video codec. It implements a multimedia standard for use by video players. Just as with \verb|libmad| there is a strong innovator driven growth.

\verb|taglib| is a library that processes metadata from multimedia files. The package allows media players to read and store information such as artist and title from multimedia files. Again, like the other multimedia packages we observe rapid innovator driven growth.

\subsection{Growth and Demise}

\begin{figure}
\small\centering
\includegraphics[width=0.6\linewidth]{BassFit-xulrunner-22.pdf}
\caption{The rise and decline of \texttt{xulrunner}. The model is fitted to the data up to 2011 (black dots).}\label{fig:xulrunner}
\end{figure}

The previous examples are all about projects that start and undergo a growth phase that can be explained by a Bass diffusion process. So far, the Bass diffusion model has appeared to give a very accurate explanation of the adoption of an open source software library.

A Bass diffusion increases monotonically, and never declines. However, not all packages follow this behaviour. Project \verb|libmad| (see Figure \ref{fig:libmad}) is a good example of this contra-behaviour. The package has an innovator driver growth that brings it close to its maximum in about two years. After that, the package's usage remains almost flat for years, and will do so indefinitely, if it is a perfect Bass diffusion process. This is called the ``maturity stage'' in product life-cycle parlance.

A real product life-cycle will also include a ``decline stage'' where the product begins to become obsolete. The Bass innovation diffusion model does not account for this. In a deep sense it would not have to as once ideas spread they become part of our collective knowledge and will continue to be used by the new products being developed. But the Bass model was not developed for the spreading of ideas, it was developed in the context of marketing, to model the adoption of products. Extending the Bass model to include obsolescence would be an interesting extension for future research.

The package \verb|xulrunner| in the dataset is a nice example of a short but complete life cycle (see Figure \ref{fig:xulrunner}). When the Bass model is applied naively and a least mean squares best-fit is made, the result is a poor fit, with $\overline{R}^2 = 96.8\%$. If one looks at the dependency growth of the package, the cause is clear: the package becomes obsolete, which the Bass model as presented in equation \ref{eq:bass-model} does not represent. The decline of the package from approximately 2011 onwards can be seen as blue dots in the figure.

Excluding the blue dots from the data results in the Bass model fit from figure \ref{fig:xulrunner}. The fitness increases to $\overline{R}^2 = 99.54\%$ and the parameters have tighter and reasonable confidence intervals. This is strong evidence that the initial adoption of the package is still a Bass diffusion process. To explain the last part, the model should be extended with an obsolescence term.

\subsection{Hypothesis Testing}

The above examples of Bass diffusion growth suggests the central hypothesis of this article: \emph{the growth in the number of open source software dependees of a project (its adoption) is a Bass innovation diffusion process}. This hypothesis is tested using a methodic approach: a random selection of ten software packages is taken and their dependee growth is fitted to the Bass diffusion model.

The Gentoo portage database contains over twenty thousand packages, but only a fraction of these packages are suitable. About six thousand packages where introduced before 2004, where the growth of Gentoo itself may be confounded. Of the remaining packages, the vast majority do not have a number of other packages depending on it, these would for example be applications (as opposed to libraries) or unpopular/niche libraries. These are filtered out by setting a lower bound for the maximum number of dependees a package has during its lifetime. Then there are infrastructural packages in Gentoo, that have no corresponding open source projects, but are used to manage the package database. In summary:

\begin{enumerate}
	\item Start with all the packages in the Gentoo portage database. (21\,380 packages)
	\item Filter out the packages that existed before 2004-01-01. (14\,706 remaining)
	\item Filter out packages that do not have at least 20 dependees at some point. (324 remaining)
	\item Filter out packages labeled ``-virtual'', ``-virtuals'', ``-proto'' or ``-meta''. (259 remaining)
\end{enumerate}

After this initial automated filtering, packages are randomly selected and manually tested against further selection criteria. If a package is rejected, a new one is randomly selected and the process is repeated until ten packages have been found. Our selection criteria are:

\begin{enumerate}
	\item[A.] The dependee growth does not contain strong discontinuities. It is very uncommon that many independent software project suddenly, within the time resolution of one month, decide to start or stop using a particular library. It is however common that maintainers of Gentoo Portage do re-organisations or mass additions/removals of packages that produce such discontinuities. Since they do not reflect actual adoption they are noise and need to be filtered out.
	\item[B.] The package corresponds to an open source software project. Some of the packages represent closed source software projects or are not software projects. These are not part of the scope and are therefore excluded.
	\item[C.] The package has not been forked of or factored out of another package. Some libraries were initially part of a different library that got refactored and split up in separate libraries and packages. Since projects may have been depending on the initial library and simply switch over to the refactored one, this cannot be considered adoption of the library. Such packages are therefore excluded.
	\item[D.] The first included version should be close to a '1.0' release. The Bass diffusion hypothesis is about the entire growth of an open source software project, it is therefore necessary to have dependee growth data from close to the beginning of the project. Packages that had an initial public release long before inclusion in Gentoo Portage are therefore excluded.
\end{enumerate}

These criteria are verified by consulting the information available through url \eqref{url:pkg}, in particular: the \texttt{changelog} of the \texttt{ebuild} file, any \texttt{readme} or \texttt{changelog} included in the earliest available version of the source code, the project's revision history and the project's homepage.

The manually rejected packages are listed in table \ref{tbl:rejected}. It should be noted that the selection criteria are chosen strictly to ensure that the main hypothesis is tested correctly, with independent open source software projects taken from their introduction and in their whole. When looking at the rejects, it does appear that some of the (\texttt{app-text/asciidoc} packages and many of the \texttt{x11-libs/} packages) still follow the Bass diffusion model.

The \texttt{x11-libs/} libraries did not qualify because they are the result of a refactor. In 2004 the X ecosystem re-organised, resulting in a fork of the XFree86 codebase and a subsequent decision to split the project up in smaller libraries. The current version was maintained in minor releases in both a split and un-split variety, but with the next major version the un-split branch was dropped. The projects show a innovator driven rapid Bass diffusion. This can be explained as the adoption of the new split release by the pre-existing users of the un-split version. The steepness can be explained by the dependers not wanting to be left behind. The innovation based drive can be explained by the relative safety and simplicity of upgrading to a new major version. A similar library-split refactor happened with the Qt library, with similar results. The complete list of the rejected packages can be seen in Table \ref{tbl:rejected}.

After rejecting the packages shown in Table \ref{tbl:rejected}, we arrive at the our final sample of 10 open source packages in Table \ref{tbl:selected}.

\begin{table}
\small\centering
\caption{The packages we rejected and the associated reasons for the rejection}\label{tbl:rejected}
\begin{tabular}{llll}
\toprule
Growth & Package & \multicolumn{2}{l}{Reason for excluding}\\
\midrule
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-173-app-arch-lzma-utils.pdf}} & \texttt{app-arch/lzma-utils} & C & (forked of LZMA SDK) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-74-app-text-asciidoc.pdf}} & \texttt{app-text/asciidoc} & D & (first release in 2002) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-23-app-text-sword-modules.pdf}} & \texttt{app-text/sword-modules} & A & (discontinuous  peak) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-35-dev-dotnet-gnome-sharp.pdf}} & \texttt{dev-dotnet/gnome-sharp} & A & (discontinuous jump) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-166-dev-haskell-hscolour.pdf}} & \texttt{dev-haskell/hscolour} & D & (original release was in 2003) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-159-dev-haskell-mtl.pdf}} & \texttt{dev-haskell/mtl} & C & (factored out of GHC) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-146-dev-java-sun-jaf.pdf}} & \texttt{dev-java/sun-jaf} & B & (not open source) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-39-dev-libs-liboil.pdf}} & \texttt{dev-libs/liboil} & A & (discontinuous  drop) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-222-dev-php-pear.pdf}} & \texttt{dev-php/pear} & D & (first released in 2002) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-150-dev-ruby-hoe.pdf}} & \texttt{dev-ruby/hoe} & A & (discontinuous  drop and jump) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-51-dev-ruby-rake.pdf}} & \texttt{dev-ruby/rake} & A & (discontinuous  jump) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-6-dev-util-cmake.pdf}} & \texttt{dev-util/cmake} & A & (discontinuous jump) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-198-dev-util-xfce4-dev-tools.pdf}} & \texttt{dev-util/xfce4-dev-tools} & C &(factored out of xfce) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-122-games-fps-quake3-bin.pdf}} & \texttt{games-fps/quake3-bin} & B &(not open source) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-60-kde-base-libkdepim.pdf}} & \texttt{kde-base/libkdepim} & C &(factored out of kdelibs) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-221-kde-base-oxygen-icons.pdf}} & \texttt{kde-base/oxygen-icons} & C &(factored out of kdelibs) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-152-mail-client-claws-mail.pdf}} & \texttt{mail-client/claws-mail} & C &(spun out of Sylpheed in 2001) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-119-media-fonts-font-cursor-misc.pdf}} & \texttt{media-fonts/font-cursor-misc} & B & (not a software project) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-79-media-libs-glew.pdf}} & \texttt{media-libs/glew} & D & (first released in 2002) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-187-x11-libs-qt-phonon.pdf}} & \texttt{media-libs/phonon} & C &(factored out of kdelibs) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-193-sys-apps-openrc.pdf}} & \texttt{sys-apps/openrc} & A & (discontinuous jump) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-72-sys-apps-sandbox.pdf}} & \texttt{sys-apps/sandbox} & A &(discontinuous spike) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-48-sys-devel-automake-wrapper.pdf}} & \texttt{sys-devel/automake-wrapper} & B &(Gentoo logistical package) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-199-x11-libs-libpciaccess.pdf}} & \texttt{x11-libs/libpciaccess} & A & (discontinuous jump) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-109-x11-libs-libSM.pdf}} & \texttt{x11-libs/libSM} & C &(factored out of Xorg) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-86-x11-libs-libXaw.pdf}} & \texttt{x11-libs/libXaw} & D &(originally from 1998) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-104-x11-libs-libXdmcp.pdf}} & \texttt{x11-libs/libXdmcp} & C &(factored out of Xorg) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-196-x11-libs-qt-demo.pdf}} & \texttt{x11-libs/qt-demo} & C &(factored out of Qt) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-180-x11-libs-qt-opengl.pdf}} & \texttt{x11-libs/qt-opengl} & C &(factored out of Qt lib) \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-185-x11-libs-qt-script.pdf}} & \texttt{x11-libs/qt-script} & C &(factored out of Qt lib) \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}
\small\centering
\caption{The 10 packages matching the selection criteria }\label{tbl:selected}
\begin{tabular}{rlp{20em}}
\toprule
Growth & Package & Description \\
\midrule
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-34-dev-dotnet-gconf-sharp.pdf}} & \texttt{dev-dotnet/gconf-sharp} & GtkSharp's gconf module \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-65-dev-haskell-cabal.pdf}}  & \texttt{dev-haskell/cabal} & Framework for packaging Haskell software \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-218-dev-libs-libunique.pdf}}  & \texttt{dev-libs/libunique} & Library for writing single instance application \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-77-dev-python-lxml.pdf}}  & \texttt{dev-python/lxml} & Python bindings for libxml2 and libxslt \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-157-dev-python-simplejson.pdf}}  & \texttt{dev-python/simplejson} & JSON encoder/decoder for Python \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-240-dev-vcs-git.pdf}}  & \texttt{dev-vcs/git} & The stupid content tracker \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-242-dev-vcs-mercurial.pdf}}  & \texttt{dev-vcs/mercurial} & Scalable distributed SCM \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-17-gnome-base-gnome-keyring.pdf}}  & \texttt{gnome-base/gnome-keyring} & Password and keyring managing daemon \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-206-media-libs-libcanberra.pdf}} & \texttt{media-libs/libcanberra} & Portable sound event library \\
\raisebox{-.15em}{\includegraphics[height=.8em]{sparkline-143-x11-misc-xdg-utils.pdf}} & \texttt{x11-misc/xdg-utils} & Portland utils for interoperability \\
\bottomrule
\end{tabular}
\end{table}
% IDs = {34, 65, 218, 77, 157, 240, 242, 17, 206, 143}

% Initial values:
%  34: 12029/6,   20, 0.671, 0.131
%  65: 24067/12, 159, 0.061, 0.491
% 218: 24109/12,  37, 0.551, 0.141
%  77: 12031/6,   65, 0.011, 0.411
% 157: 24059/12, 104, 0.011, 0.421
% 240: 12031/6,  746, 0.000, 0.730
% 242: 2004,     159, 0.001, 0.621
%  17: 2004,      43, 0.021, 0.991
% 206: 8035/4,    37, 0.201, 0.961
% 143: 24083/12, 115, 0.041, 0.341

% 34-dev-dotnet-gconf-sharp:

\begin{figure}
\small\centering
% 34, 65, 218, 77, 157, 240, 242, 17, 206, 143
\subfigure[\texttt{dev-dotnet/gconf-sharp}]{\includegraphics[width=0.45\textwidth]{BassFit-34-dev-dotnet-gconf-sharp.pdf}\label{fig:fit34}}
\subfigure[\texttt{dev-haskell/cabal}]{\includegraphics[width=0.45\textwidth]{BassFit-65-dev-haskell-cabal.pdf}\label{fig:fit65}}
\subfigure[\texttt{dev-libs/libunique}]{\includegraphics[width=0.45\textwidth]{BassFit-218-dev-libs-libunique.pdf}\label{fig:fit218}}
\subfigure[\texttt{dev-python/lxml}]{\includegraphics[width=0.45\textwidth]{BassFit-77-dev-python-lxml.pdf}\label{fig:fit77}}
\subfigure[\texttt{dev-python/simplejson}]{\includegraphics[width=0.45\textwidth]{BassFit-157-dev-python-simplejson.pdf}\label{fig:fit157}}
\subfigure[\texttt{dev-vcs/git}]{\includegraphics[width=0.45\textwidth]{BassFit-240-dev-vcs-git.pdf}\label{fig:fit240}}
\subfigure[\texttt{dev-vcs/mercurial}]{\includegraphics[width=0.45\textwidth]{BassFit-242-dev-vcs-mercurial.pdf}\label{fig:fit242}}
\subfigure[\texttt{gnome-base/gnome-keyring}]{\includegraphics[width=0.45\textwidth]{BassFit-17-gnome-base-gnome-keyring.pdf}\label{fig:fit17}}
\subfigure[\texttt{media-libs/libcanberra}]{\includegraphics[width=0.45\textwidth]{BassFit-206-media-libs-libcanberra.pdf}\label{fig:fit206}}
\subfigure[\texttt{x11-misc/xdg-utils}]{\includegraphics[width=0.45\textwidth]{BassFit-143-x11-misc-xdg-utils.pdf}\label{fig:fit143}}
\caption{Bass curve fits on ten randomly selected packages that met the criteria.}
\end{figure}


\begin{table}
\small\centering
\caption{Results of fitting the Bass model.}\label{tbl:testresults}
\begin{tabular}{lr@{ $\pm$}rr@{ $\pm$}rr@{ $\pm$}rr}
\toprule
Package & \multicolumn{2}{c}{$p$} & \multicolumn{2}{c}{$q$} & \multicolumn{2}{c}{$M$} & $\overline{R}^2$\\
\midrule
% 34, 65, 218, 77, 157, 240, 242, 17, 206, 143
\texttt{dev-dotnet/gconf-sharp}   & 0.168 & 0.212 & 0.754 & 0.434 &  21 &   1 & 99.61\%\\
\texttt{dev-haskell/cabal}        & 0.055 & 0.074 & 0.154 & 0.380 & 246 & 438 & 98.55\%\\
\texttt{dev-libs/libunique}       & 0.047 & 0.099 & 0.136 & 0.402 & 287 & 732 & 98.58\%\\
\texttt{dev-python/lxml}          & 0.007 & 0.009 & 0.488 & 0.217 &  53 &  53 & 98.82\%\\
\texttt{dev-python/simplejson}    & 0.011 & 0.029 & 0.463 & 0.459 &  97 & 148 & 98.98\%\\
\texttt{dev-vcs/git}              & 0.000 & 0.006 & 0.841 & 0.144 & 734 & 369 & 99.24\%\\
\texttt{dev-vcs/mercurial}        & 0.001 & 0.005 & 0.517 & 0.259 & 174 & 481 & 98.24\%\\
\texttt{gnome-base/gnome-keyring} & 0.026 & 0.036 & 0.833 & 0.133 &  42 &   2 & 99.66\%\\
\texttt{media-libs/libcanberra}   & 0.055 & 0.117 & 1.436 & 0.439 &  37 &   3 & 99.68\%\\
\texttt{x11-misc/xdg-utils}       & 0.050 & 0.043 & 0.257 & 0.242 & 115 & 127 & 99.56\%\\
\bottomrule
\end{tabular}
\end{table}

The packages \texttt{dev-python/lxml} (Figure \ref{fig:fit77}) and \texttt{dev-cvs/mercurial} (Figure \ref{fig:fit242}) show a staircase-shaped deviation from the Bass diffusion model. This can be explained as discretisation noise. The number of dependees is an integer and can therefore only rise or fall in discrete steps, whereas the Bass model is continuous and smooth. This introduces additional variance which lowers the $\overline{R}^2$ metric. It also appears to happen in \texttt{dev-haskell/cabal} (Figure \ref{fig:fit65}), but this is an illusion since the steps in the growth are not singular but in the order of tens of packages. The reasons for these steps are unknown and likely related to Gentoo internal matters. \texttt{dev-libs/libunique} (Figure \ref{fig:fit218}) does not fit the Bass diffusion model well, and it appears to be for the same reasons that have been presented earlier for \texttt{xulrunner}, i.e. that its adoption represents initial growth and later demise. Despite this, all packages show $\overline{R}^2$ values over $98\%$, as seen in Table \ref{tbl:testresults}.

\section{Conclusions and Future Work}

We have shown that the growth of the number of packages depending on a package can be modelled as a a Bass diffusion process \citep{bass69}. The Bass diffusion model is a theory that explains and predicts (also known as a type IV theory, according to \citep{gregor06}). What we have shown in this paper is a fit of this theory to explain the process by which open source libraries are adopted. Overall we see that the Bass diffusion model gives very a good fit for most OSS projects. Using only four parameters, it is able to describe the growth curves from the empirical data. Full statistical rigour would require a more involved analysis using the methods from, for example, \citet{carlos06}. But given the amount of and quality of evidence found, we can conclude that most OSS project do follow the Bass diffusion model.

As can be seen in \ref{tbl:results}, the Bass parameters $p$ and $q$ are difficult to interpret and compare. A high $p$ does not automatically mean an innovator driven growth: if the $q$ value is also high then the result is simply a lot of growth. For the same reason it is also difficult to compare the $p$ and $q$ between packages. \citet{mahajan95} suggests using $\frac{q}{p}$ and $q + p$, this represents the total adoption rate and an imitator/innovator ratio.

Analysing the package dependency graph and its changes over time can provide new insights. Our exploratory study provides some evidence for insights such as how multimedia libraries are being adopted through an innovator driven process with low-level architectural changes happening slowly and through imitation. Further studies could test this and related hypotheses.

The package dependency graph contains empirical data to test extensions of the Bass diffusion model - extended with discarders. The Bass model and the present analysis is formulated in terms of absolute number of users, but in most applications only sales figures are available. The amount of sales is the first derivative of the Bass model, hence the model is usually applied in its derivative form \citep{mahajan95}. As a consequence, the model only considers adopters, but does not consider \emph{discarders}. In the \texttt{xulrunner} example, we see the package being discarded from 2011 onwards, providing insights into the discarding mechanism. The next step would be to collect more examples of packages being discarded, and looking at the patterns of demise and perhaps developing a model of discarding to supplement the Bass model of adoption. One model could for example be the inverse of a Bass curve, this makes sense when the market share of the original package is taken over by a new package. The unique feature of dependency graph analysis to give absolute user numbers facilitates this. Such an analysis can also help in predicting the behaviour of certain projects - hence forewarning the particular project stakeholders. As the extent of adoption of an open source project is an indication of how popular the project is and in-turn an indication of the health of the project as assessed by the open source community, we can use this predictive adoption to typically supplement the existing analysis of open source project health \citep{daniel13,amrit10a,piggot13}.

The scale and complexity of the dependency graphs and open source innovation requires some attention. Three notable issues became apparent in this study: first, that in the open source community there is a lot of forking. It is not always clear whether a forked project constitutes the continuation of the original project or a separate new project. A more thorough study on the nature of forking could provide the insights to resolve this issue. Second, due to the public nature of open source development many immature or abandoned projects are visible in the larger datasets. This is good from a scientific perspective as it allows one to research projects from their beginning stages and one can look at projects that failed to grow or those that became obsolete. But it clouds the `big picture' with many projects that do not significantly contribute to the overall innovation. In large datasets one would have to devise a relevance metric to select the relevant metrics. Such metrics could be the number of developers, the number of users or the number of dependees. Third, the sheer scale of the available OSS databases provide challenges for analysis. Specialist tooling is required to transform the raw data into more manageable formats.


\bibliographystyle{plainnat}
\bibliography{paper}

\appendix
\section{Dataset}

The dataset collected is available at
\begin{align}
\mbox{\href{http://datahub.io/dataset/gentoo-dependency-graph}{\texttt{http://datahub.io/dataset/gentoo-dependency-graph}}}
\end{align}
as compressed GML graphs for every snapshot. Raw data is available at
\begin{align}
\mbox{\url{http://www.utwente.nl/mb/iebis/staff/amrit/timeline.squashfs}}
\end{align}
as a SquashFS compressed filesystem. The SquashFS format allows one to mount the compressed data as a read-only disk drive and operate directly on the dataset. It contains the pre-processed ebuild files and the file \verb|graphs.bip| that contains all of the graphs in a custom format specialized for quick processing of large graphs over time. A C++ toolkit to work with the \verb|graphs.bip| file is available at \url{https://github.com/Recmo/depgraph}.

\section{Selecting the right dataset}

\begin{table}[h]\centering\small
\caption{Major FOSS distributions and their package databases.}
\label{tbl:pkgmngrs}
\sbox\sfloat{\begin{tabular}{llllrl}
\toprule
& Initial release & package manager & source/binary & packages & release cycle \\
\midrule
Ubuntu           & 20-10-2004 & dpkg     & binary & 34,580 & $\frac12$ year \\
Fedora/Red Hat   & 13-04-1995 & rpm      & binary &  7,334 & $\frac12$ year \\
(open)SUSE       & 01-03-1994 & rpm      & binary &  6,011 & $1$ year \\
Debian           & 17-06-1996 & dpkg     & binary & 40,163 & $2$ year \\
Mandriva         & 23-06-1998 & rpm      & binary &  5,779 & $\frac12$ year \\
Mint             & 27-08-2006 & dpkg     & binary & 30,000 & $\frac12$ year \\
PCLinuxOS        & 01-10-2003 & rpm      & binary & - & $\frac12$ year \\
Slackware        & 16-07-1993 & pkgtools & binary & 10,590 & $1$ year \\
Gentoo           & 31-03-2002 & portage  & source$^a$ & 14,018 & rolling \\
CentOS           & 14-05-2004 & rpm      & binary &  2,599 & $\frac12$ year \\
FreeBSD          & 01-11-1993 & ports    & source & 22,020 & $\frac12$ year \\
\bottomrule
\end{tabular}}\usebox\sfloat
\\
\footnotesize
\begin{tabulary}{\wd\sfloat}{r@{\,}>{\raggedright\arraybackslash}L}
$^a$ & About 100 packages are also provided in binary form.\\
\multicolumn{2}{>{\raggedright\arraybackslash}p{\wd\sfloat}}{
Source: Based on Distrowatch, data from Wikipedia and respective distribution websites.
}\\
\end{tabulary}
\end{table}

Table~\ref{tbl:pkgmngrs} lists the popular Linux distributions. For each distribution a number of details is given in the columns. The date of its first published version is given. The `package manager' refers to the system used to install and maintain software in a running system. This is relevant for this paper since the package manager must know what packages depend on what other packages so that it installs all the prerequisites. The `source/binary' column specifies whether the packages are installed by compiling the source code or if the distribution provides pre-compiled binaries. The later case is more popular since compiling software is very slow and error prone compared to simply copying pre-compiled files. The last columns list the number of packages in the package database at the time of writing and the average duration between new versions of the package database. Gentoo is unique in that it does not periodically release a new version of the package database, but updates its database as new versions of packages become available.

Reflecting on the qualities of a dataset the numbers of packages do not seem too impressive at first sight. But unlike the previous datasets there are few insignificant packages, no distribution would like to spend time supporting a package that is unfinished or abandoned by its original developers. On the other hand, their user base requires them to include all the popular projects. Given that the most relevant packages are included, the fact that the list does not include `noise' in the form of insignificant projects could be considered a bonus.

A distinctive advantage of distribution package databases is that they contain very good dependency information. The package database needs to contain correct dependency for correct operation of the system and since the package manager operates automatically this information needs to be fully codified. With relative ease one can extract the entire dependency graph from the package database. This greatly facilitates gathering a dataset.

\emph{Source} distributions will necessarily contain more a more complete dependency graph than \emph{binary} distributions. Both kinds of package databases need to list all the dependencies required to \emph{use} a particular package, but source base distribution need to include all de packages required to \emph{compile} and \emph{use} the project.

The Gentoo portage database and the FreeBSD ports databases are ideal candidates. Both have all the good qualities of a source based package database. FreeBSD has the advantage that it has a long history and more packages, Gentoo has the advantage that it has better time resolution. Also since the first author is very familiar with Gentoo's database, we chose the Gentoo portage database as the data source for this article.

For more details on the process of selecting the database please see \citep{bloemen12}.

\end{document}
